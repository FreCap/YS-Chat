1) Un poolThread di netty che in automatico gestisce le connessioni.

2) se netty gestisce il suo pool di thread in modo che, se il thread k 
    è impegnato a fare un'operazione complessa ( come una query al DB ),
	apre automaticamente un nuovo thread x gestire	il nuovo evente di un 
    channel ( come una nuova connessione.. ), possiamo tranquillamente
	non preoccuparci di fare un sistema di queue su un altro thread, ma 
    semplicemente assicurarci che esista sempre una connessione 
	attiva al server mysql ( e quindi impedire una nuova connessione per 
    ogni operazione fatta )

3) package sn.net PresenceHandler.java:
	
	static final ChannelGroup channels = new DefaultChannelGroup(); // in cui mettere le varie connessioni.
	
	{ricordo k per ritrovare la connessione basta fare channels.find(id_connessione)}
	{con e.getChannel().getId() trovi l'id della connessione}

	// dichiarare l'evento channelConnected
	@Override
	public void channelConnected
	
	basta fare un channels.add(e.getChannel())
		
	GESTIRE LA CONNESSIONE
	
	@Override
	public void messageReceived(ChannelHandlerContext ctx, MessageEvent e)
			throws Exception {
		
		String messaggio = (String) e.getMessage();		
		String[] splitted = messaggio.split(" ",2);

		int azione = Integer.parseInt(splitted[0]);
		String value = splitted[1];
		
		switch (azione) {
		case LOGIN:
			profilo profilo = new profilo();
			data = value.split(" ");
			profilo.login(e.getChannel(),data[0],data[1]);
			break;
		}
		
		super.messageReceived(ctx, e);
	}
	
	dovrà gestire una serie di switch del messaggio 
	TIPO_MSG VALUE
	il value spesso è a sua volta suddiviso da spazi, per questo ho usato 
    split(" ",2), in modo che divida soltanto l'azione dal value. 
    Vedi sotto nell'esempio del LOGIN un value possibile
	
	i tipi msg devono essere definiti da una var static/enum
	eventualmente creare delle classi x definire i msg in modo più carino, 
    da decidere qual'è la maniera migliore
	ad es.
		PSEUDOCODE
		class action_LOGIN{
			int profilo_id;
			int chat_key;
			int MSG = LOGIN;// l'enum
			func set_profilo_id(profilo_id)
			func set_chat_key(chat_key)
			func set_fromString(string)
			func toString()
		}
	
	TODO:
	CHG_STATUS
		-> value = (INT)profilo_id (INT)status (String)nickname
	LOGIN
		-> value = (INT)profilo_id (String)chat_key
		PSEUDOCODE
		profilo profilo new profilo();
		profilo->login(e->getChannel(),profilo_id,chat_key);
		
		package sn.profilo profilo.java
		
			class profilo
				static profili = concurrentHashMap<int,profilo> // dv int è ovviamente l'profilo id
				int[] channels_id // i channel appartenenti all'profilo
				int[] friends_online;
				int[] chat_opened;
				int chat_active;
				String nickname;
				int profilo_id;
				int status;
				
				login(channel, profilo_id, chat_key){
					->check che l'profilo esista facendo un select dal db mysql, in fase di test si può anche nn fare || return 1 if error
					->check k la chat_key sia uguale a quella del db || return 2 if error
					->inserisci il channel.getId in channels_id, inserisci this in profili
					->set Status online ( basta fare un semplice enum x gli stati )
					->load friends, e check di chi è online tramite profili.get(profilo_id)
						->segnala online tramite un ciclo for degli profilo amici, profilo_amico->friend_status(this);
				}
			
				friend_status(profilo profilo){
					String msg = CHG_STATUS+" "+profilo->profilo_id+" "+profilo->status+" "+profilo->nickname;
					for(int channel_id: profilo->channels_id){
						PresenceHandler::channels->find(channel_id)->write(msg);
					}
					if(profilo->status == OFFLINE){
						friend_remove(profilo->profilo_id)
					}
				}
				
				friend_add(profilo_id){
					friends_online.add(profilo_id);
				}

				friend_remove(profilo_id){
					friends_online.remove(profilo_id);
				}
				channel_add(channel_id){
					boolean added = profili.add(channel_id, channel) == null;
					 if (added) {
						PresenceHandler::channels.find(channel_id).getCloseFuture().addListener(channel_remove);
					 }
				}
				
				channel_remove(channel){
					channels_id.remove(channel.getId())
					if(channels_id.size()==0){
						logout();
					}
				}
				
				logout(){
					->set status offline
					->notifica friends list
					->remove from profili
				}
			}

	
	